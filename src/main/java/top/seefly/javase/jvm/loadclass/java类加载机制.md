## java类加载机制

#### 1、什么是类加载

​	是指将类的class文件数据加载到内存中，将二进制数据经过一系列步骤转换成可以虚拟机处理的数据结构并存放到运行时数据区的方法区内，并在堆内存中生成一个对应的Class对象。此外这个Class对象封装了类在方法区内的数据结构，并对外暴露了访问这个数据结构的接口。

- 类加载并不总是在需要的时候才进行
- 类加载是一个将二进制数据恢复成虚拟机可以处理的数据结构的过程



------

#### 2、类的加载过程

​	**加载 ----> 验证 ----> 准备 ----> 解析 ----> 初始化**

​	注意，加载、验证、准备、初始化这四个步骤的相对开始顺序是确定的，但不表示B的开始一定在A的结束之后，同时解析阶段开始顺序则是不确定的，可能会在初始化阶段开始之后，这是为了支持Java的动态绑定。

##### 2.1、类加载

1. 通过类的全限定名从某个地方获取它的二进制字节流
2. 将字节流代表的静态存储结构转化为方法区的运行时数据结构
3. 在java内存中生成一个代表这个类的Class对象(对于HotSpot来说，它放在方法区)

##### 加载.class文件的途径？

由于虚拟机规范中没有明确定义如何加载一个类，所以这一块比较灵活。可以通过下面几种方式来进行。

- 从本地系统中直接加载
- 通过网络下载
- 从zip jar等归档文件中加载
- 从数据库中提取
- 将Java源文件动态编译为.class文件

##### 什么时候会加载一个类？

- 虚拟机规范中并没有进行强制约束，这个可以交由虚拟机自由实现。

##### 2.2、验证

​	验证阶段就是相当于一个安全检查，确保加载进来的Class文件不是乱七八糟的东西。它会从下面四个维度进行校验。

- **文件格式验证**

  验证加载进来的是不是class文件，即以咖啡宝贝开头的，还有版本号啥的。

- **元数据验证**

  验证这个类是否有父类、是否继承了final类等

- **字节码验证**

  主要是验证方法体

- **符号引用验证**

  如果当前类引用了其他的类，那么能不能通过符号引用来找到对应的类，以及调用这个类的方法存不存在等。

> 问题
>
> 为什么在数据都加载进来了才进行验证操作？
>
> 答：
>
> 类加载阶段一般是和验证阶段交叉进行的，也就是边加载边验证。

##### 2.3、准备

​	准备阶段是为类变量分配内存并设置类变量初始值的阶段，这些内存的分配都在方法区内。

- static关键字修饰的类变量分配内存，而成员变量是属于类实例的，需要在堆中分配
- 类变量设置初始值，如几个基本类型的int类型为0，long的为0L....
- 如果是常量即同时被static final修饰的属性，则在该阶段就进行赋值操作。

##### 2.4、解析

​	该阶段将常量池中的符号引用替换为直接引用的过程。直接引用就相当于直指目标的指针、句柄等。

> 什么是符号引用？
>
> 符号引用就是一组符号来描述所引用的目标，例如你的名字就是对你的符号引用。

##### 2.5、 初始化

​	类的初始化和实例的初始化是两码事，这个阶段指的是类的初始化。初始化阶段其实就是执行<clinit>()方法的过程，这个方法是虚拟机采集的类变量的赋值动作，和静态代码块的语句所组成的。需要注意的是子类的类构造方法会在父类的类构造方法之后执行，这一点由虚拟机保证。并且执行这个方法是加锁的。

**关键点**

- <clinit>()方法 = 类变量的赋值动作+静态代码块。若这两个都没有，则不生成该方法。
- 先执行父类的类构造方法
- 执行类的构造方法是加锁的

以下几种主动使用的方式会导致**类的初始化**：

- 创建实例对象(都创建实例了肯定先初始化类)
- 访问类成员(访问类成员肯定先给类成员准备好)
- 调用类的静态方法(静态方法可以访问类成员)
- Class.forName("XXX")
- 子类被初始化之前父类要先初始化
- 虚拟机的启动类



#### 3、加载器

##### 3.1 类和类加载器

**关键点**：即使两个相同的类被不同的类加载器所加载，那么这两个类也不是相等的。例如使用Class.equals()进行比较或者instanceof关键字进行比较都是不相等的。

##### 3.2 双亲委派模型

**几种类加载器**

1. 启动类加载器: BootstrapClassLoader

   负责加载 ${JAVA_HOME}/jre/lib 文件夹下的类库

2. 扩展类加载器： ExtensionClassLoader

   负责加载 ${JAVA_HOME}/jre/lib/ext 文件夹下的类库

3. 应用程序类加载器： ApplicationClassLoader

   该类加载器由 sun.misc.Launcher$AppClassLoader来实现，它负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器。 如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。

**双亲委派机制**：

如果一个类加载器收到了加载类的请求，它首先不会自己去主动加载这个类，而是委派父类加载器去加载，每一层都是如此，所以所有的加载请求都会到达顶层的启动类加载器上。只有当启动类加载器无法完成加载请求时，子加载器才会去加载。

**双亲委派机制的好处：**

例如对于放在rt.jar包中的Object类，使用哪个类加载器加载，请求最终都会到达启动类加载器。这样就确保了使用不同的类加载器最终加载到的都是同一个类。维护了基本的运行环境。

